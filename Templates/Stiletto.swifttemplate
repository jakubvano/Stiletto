<%

// TODO: find better name
struct Member: Equatable {
    let name: String
    let typeName: String
    let type: Type

    enum Error: Swift.Error {
        case missingType(Typed)
    }

    init(_ parameter: Typed) throws {
        guard let type = parameter.type else { throw Member.Error.missingType(parameter) }
        self.init(type)
    }

    init(_ type: Type) {
        self.name = Member.name(for: type.name)
        self.typeName = Member.typeName(for: type.name)
        self.type = type
    }

    static func name(for typeName: String) -> String {
        return Utils.camelCased(typeName) + "Provider"
    }

    static func typeName(for typeName: String) -> String {
        return "Provider<\(typeName)>"
    }
}

struct Component {
    let implementationName: String
    let interfaceName: String
    let members: [Member]
    let variables: [Variable]

    init(_ type: Type) throws {
        implementationName = "Stiletto\(type.name)"
        interfaceName = type.name
        variables = type.variables

        // TODO: Performance
        members = try Component.allDependencies(for: type.variables)
            .sorted(by: Component.dependencyTreeOrdering)
            .map(Member.init)
    }

    static func allDependencies(for variables: [Typed]) throws -> [Type] {
        let types: [Type] = try variables
            .map { if let type = $0.type { return type } else { throw Member.Error.missingType($0) } }
        return try allDependencies(for: types)
    }

    static func allDependencies(for types: [Type]) throws -> [Type] {
        return try types
            .map(Factory.init)
            .flatMap { $0.members }
            .map { [$0.type] }
            .map(allDependencies)
            .reduce(types, +)
            .reduce([], Utils.appendIfNew)
    }

    static func dependencyTreeOrdering(_ type1: Type, _ type2: Type) throws -> Bool {
        return try allDependencies(for: [type2]).contains(type1)
    }
}

enum Utils {
    static func isInjectable(_ identifier: Annotated) -> Bool {
        return identifier.annotations.keys.contains("Inject")
    }

    static func isComponent(_ identifier: Annotated) -> Bool {
        return identifier.annotations.keys.contains("Component")
    }

    static func camelCased(_ name: String) -> String {
        return name.prefix(1).lowercased() + name.dropFirst()
    }

    static func appendIfNew<T: Equatable>(array: [T], element: T) -> [T] {
        return array.contains(element) ? array : array + [element]
    }
}

struct Stiletto {
    let components: [Component]
    let factories: [Factory]

    init(_ types: Types) throws {
        components = try types.protocols.filter(Utils.isComponent).map(Component.init)
        factories = try components
            .flatMap { $0.members }
            .map { $0.type }
            .reduce([], Utils.appendIfNew)
            .map(Factory.init)
    }
}

struct Factory {
    let interfaceName: String
    let implementationName: String
    let instanceTypeName: String
    let members: [Member]
    let constructor: SourceryRuntime.Method

    enum Error: Swift.Error {
        case noInit(Type)
        case multipleInits(Type)
    }

    init(_ type: Type) throws {
        let constructors = type.methods.filter(Utils.isInjectable).filter { $0.callName == "init" }

        guard !constructors.isEmpty else { throw Factory.Error.noInit(type) }
        guard constructors.count == 1 else { throw Factory.Error.multipleInits(type) }

        self.interfaceName = "Provider<\(type.name)>"
        self.implementationName = "\(type.name)$$Factory"
        self.instanceTypeName = type.name
        self.constructor = constructors[0]
        self.members = try constructor.parameters.map(Member.init)
    }
}
%>
class Provider<T> {
    var instance: T { fatalError() } // To Be Overriden
}

<% do { let stiletto = try Stiletto(types) %>
  <% for component in stiletto.components { %>
    <%- include("Partial/Component.swifttemplate") %>
  <% } %>
  <% for factory in stiletto.factories { %>
    <%- include("Partial/Factory.swifttemplate") %>
  <% } %>
<% } catch let error { %>
    // Stiletto Generation Failed
    // TODO: Error handling
    // <%= error %>
<% } %>
