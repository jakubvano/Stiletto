<%

struct Member: Equatable {
    let name: String
    let typeName: String
    let type: Type

    enum Error: Swift.Error {
        case missingType
    }

    init(_ parameter: Typed) throws {
        guard let type = parameter.type else { throw Member.Error.missingType }
        self.init(type)
    }

    init(_ type: Type) {
        self.name = Member.name(for: type.name)
        self.typeName = Member.typeName(for: type.name)
        self.type = type
    }

    static func name(for typeName: String) -> String {
        return Utils.camelCased(typeName) + "Provider"
    }

    static func typeName(for typeName: String) -> String {
        return "Provider<\(typeName)>"
    }
}

struct Component {
    let implementationName: String
    let interfaceName: String
    let members: [Member]
    let variables: [Variable]

    init(_ type: Type) throws {
        implementationName = "Stiletto\(type.name)"
        interfaceName = type.name
        members = try allDependencies(for: type.variables).map(Member.init)
        variables = type.variables
    }
}

func allDependencies(for variables: [Typed]) throws -> [Type] {
    let types: [Type] = try variables
        .map { if let type = $0.type { return type } else { throw Member.Error.missingType } }
    return try allDependencies(for: types)
}

func allDependencies(for types: [Type]) throws -> [Type] {
    return try types
        .map(Factory.init)
        .flatMap { $0.members }
        .map { [$0.type] }
        .map(allDependencies)
        .reduce(types, +)
        .reduce([], Utils.appendIfNew)
}

enum Utils {
    static func isInjectable(_ identifier: Annotated) -> Bool {
        return identifier.annotations.keys.contains("Inject")
    }

    static func camelCased(_ name: String) -> String {
        return name.prefix(1).lowercased() + name.dropFirst()
    }

    static func appendIfNew<T: Equatable>(array: [T], element: T) -> [T] {
        return array.contains(element) ? array : array + [element]
    }
}

struct Factory {
    let interfaceName: String
    let implementationame: String
    let instanceTypeName: String
    let members: [Member]
    let constructor: Method

    enum Error: Swift.Error {
        case noInit
        case multipleInits
    }

    init(_ type: Type) throws {
        let constructors = type.methods.filter(Utils.isInjectable).filter { $0.name == "init" }

        guard !constructors.isEmpty else { throw Factory.Error.noInit }
        guard constructors.count == 1 else { throw Factory.Error.multipleInits }

        self.interfaceName = "Provider<\(type.name)>"
        self.implementationame = "\(type.name)$$Factory"
        self.instanceTypeName = type.name
        self.constructor = constructors[0]
        self.members = try constructor.parameters.map(Member.init)
    }
}
%>
